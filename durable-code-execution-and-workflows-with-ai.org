#+TITLE: Durable Code Execution and Workflows with AI
#+AUTHOR:
#+OPTIONS: toc:3

* Introduction

Durable execution bridges the gap between predictable workflows and unpredictable AI behavior. This document explores the architectural patterns needed to make AI agent executions reliable, recoverable, and production-ready.

* The Core Dilemmas

** Deterministic vs Non-Deterministic Execution

*** The Problem

| Aspect          | Workflows                              | AI Agents                                    |
|-----------------+----------------------------------------+----------------------------------------------|
| Execution Path  | Predefined order                       | Runtime decisions                            |
| Predictability  | Known outcomes                         | Unknown until LLM responds                   |
| Components      | Steps + Flow + Conditions + Retries    | Tool calls, MCPs, Function calling           |
| Recovery        | Replay exact same path                 | May take different path on restart           |

*** Visual Representation

#+BEGIN_SRC mermaid
flowchart LR
    subgraph Deterministic["Deterministic Workflow"]
        direction TB
        W1[Step 1] --> W2[Step 2]
        W2 --> W3{Condition}
        W3 -->|Yes| W4[Step 3A]
        W3 -->|No| W5[Step 3B]
        W4 --> W6[Step 4]
        W5 --> W6
    end

    subgraph NonDeterministic["Non-Deterministic AI Agent"]
        direction TB
        A1[Goal] --> A2{LLM Decision}
        A2 -->|Tool A| A3[Execute Tool A]
        A2 -->|Tool B| A4[Execute Tool B]
        A2 -->|Tool C| A5[Execute Tool C]
        A3 --> A6{Next Decision}
        A4 --> A6
        A5 --> A6
        A6 -->|???| A7[Unknown Path]
    end

    Deterministic -.->|"Known at Design Time"| Result1[Predictable]
    NonDeterministic -.->|"Known at Runtime"| Result2[Unpredictable]
#+END_SRC

** AI Agent History vs Persisted Checkpoints

*** Distinction

- *AI Agent History*: Traces agent actions for observability and debugging
- *Persisted Checkpoints*: Captures actual work state for recovery and resumption

*** The Relationship

#+BEGIN_SRC mermaid
flowchart TB
    subgraph AgentHistory["Agent History (Observability)"]
        H1[Action 1: Called LLM]
        H2[Action 2: Selected Tool X]
        H3[Action 3: Executed Tool X]
        H4[Action 4: Called LLM again]
        H1 --> H2 --> H3 --> H4
    end

    subgraph Checkpoints["Persisted Checkpoints (Durability)"]
        C1[Checkpoint 1<br/>State: Initial<br/>Context: Input Data]
        C2[Checkpoint 2<br/>State: After Tool X<br/>Context: Tool Result + Position]
        C3[Checkpoint 3<br/>State: Completed<br/>Context: Final Output]
    end

    AgentHistory -->|"Different Purpose"| Checkpoints

    H3 -.->|"Triggers"| C2

    style AgentHistory fill:#e1f5fe
    style Checkpoints fill:#fff3e0
#+END_SRC

* What Makes Execution Durable

** Core Requirements

1. *Checkpoints at Every Step*
   - Work and tasks must have checkpoints
   - Not just "task completed" but complete state snapshots

2. *Rich Checkpoint Content*
   - Progress indicators
   - Execution context
   - Position in ordered flow
   - Input/output data

3. *Persistent Storage*
   - Start to finish persistence
   - All intermediate steps included
   - Survives process crashes

** Checkpoint Architecture

#+BEGIN_SRC mermaid
flowchart TB
    subgraph Execution["Workflow Execution"]
        E1[Task 1] --> E2[Task 2] --> E3[Task 3] --> E4[Task 4]
    end

    subgraph Storage["Durable Storage"]
        S1[(Checkpoint 1)]
        S2[(Checkpoint 2)]
        S3[(Checkpoint 3)]
        S4[(Checkpoint 4)]
    end

    E1 -->|"Save State"| S1
    E2 -->|"Save State"| S2
    E3 -->|"Save State"| S3
    E4 -->|"Save State"| S4

    subgraph Recovery["Fault Recovery"]
        R1[Crash at Task 3]
        R2[Load Checkpoint 2]
        R3[Resume from Task 3]
    end

    S2 -.->|"On Failure"| R2
    R2 --> R3

    style Storage fill:#c8e6c9
    style Recovery fill:#ffcdd2
#+END_SRC

** Checkpoint Data Model

#+BEGIN_SRC mermaid
classDiagram
    class Checkpoint {
        +String id
        +String workflowId
        +int stepNumber
        +DateTime timestamp
        +ExecutionState state
        +Map context
        +byte[] serializedData
        +String parentCheckpointId
    }

    class ExecutionState {
        <<enumeration>>
        PENDING
        RUNNING
        PAUSED
        WAITING_APPROVAL
        COMPLETED
        FAILED
        CANCELLED
    }

    class WorkflowExecution {
        +String id
        +String workflowType
        +DateTime startTime
        +DateTime endTime
        +List~Checkpoint~ checkpoints
        +Checkpoint currentCheckpoint
    }

    Checkpoint --> ExecutionState
    WorkflowExecution --> Checkpoint : has many
#+END_SRC

* Making AI Agents Durable

** Requirements for Durable AI Agents

1. *Long-Lived Processes*
   - Not ephemeral request handlers
   - Maintain state across interactions
   - Survive restarts and failures

2. *Continuous Work Polling*
   - Check for new work on schedule or in loop
   - React to events and triggers
   - Handle backpressure gracefully

3. *Work-in-Progress Tracking*
   - Know what tasks are active
   - Resume incomplete work after restart
   - Prevent duplicate execution

** Durable Agent Lifecycle

#+BEGIN_SRC mermaid
stateDiagram-v2
    [*] --> Initializing
    Initializing --> Polling : Agent Started

    Polling --> Processing : Work Available
    Polling --> Polling : No Work (Wait)

    Processing --> Checkpointing : Step Completed
    Checkpointing --> Processing : More Steps
    Checkpointing --> Polling : Work Complete

    Processing --> Recovering : Failure Detected
    Recovering --> Checkpointing : Load Last Checkpoint

    Processing --> WaitingApproval : Human Gate
    WaitingApproval --> Processing : Approved
    WaitingApproval --> Cancelled : Rejected

    Polling --> Shutdown : Graceful Stop
    Cancelled --> Polling
    Shutdown --> [*]
#+END_SRC

** Separation of Concerns Pattern

#+BEGIN_SRC mermaid
flowchart TB
    subgraph DeterministicLayer["Deterministic Workflow Layer"]
        WF1[Workflow Orchestrator]
        WF2[Step Sequencer]
        WF3[Retry Logic]
        WF4[Checkpoint Manager]
    end

    subgraph NonDeterministicLayer["Non-Deterministic Activity Layer"]
        ACT1[LLM Call Activity]
        ACT2[Tool Execution Activity]
        ACT3[External API Activity]
    end

    subgraph PersistenceLayer["Persistence Layer"]
        DB1[(Event History)]
        DB2[(Checkpoints)]
        DB3[(Agent State)]
    end

    WF1 --> WF2
    WF2 --> WF3
    WF3 --> WF4

    WF2 -.->|"Invoke"| ACT1
    WF2 -.->|"Invoke"| ACT2
    WF2 -.->|"Invoke"| ACT3

    ACT1 -->|"Result Persisted"| DB1
    ACT2 -->|"Result Persisted"| DB1
    ACT3 -->|"Result Persisted"| DB1

    WF4 -->|"Save"| DB2
    WF1 -->|"Track"| DB3

    DB1 -.->|"Replay on Recovery"| WF2

    style DeterministicLayer fill:#e8f5e9
    style NonDeterministicLayer fill:#fff8e1
    style PersistenceLayer fill:#e3f2fd
#+END_SRC

* Important Remarks

** LLM Calls vs Agent Implementation

- *Straight LLM calls* by themselves are NOT agent implementations
- An agent requires: goals, decision-making, tool selection, state management
- LLM is just one component in the agent architecture

** Workflow-LLM Integration

#+BEGIN_SRC mermaid
flowchart LR
    subgraph Workflow["Deterministic Workflow"]
        S1[Step 1: Validate Input]
        S2[Step 2: LLM Summarization]
        S3[Step 3: Store Result]
        S4[Step 4: Notify User]
        S1 --> S2 --> S3 --> S4
    end

    subgraph LLMCalls["LLM Calls (Non-Deterministic)"]
        L1[GPT-4 for Summarization]
        L2[Claude for Classification]
        L3[Local LLM for Validation]
    end

    S2 -.->|"Invoke"| L1

    subgraph AIAgent["Triggering AI Agent"]
        A1[Agent with<br/>Different Model]
    end

    A1 -->|"Triggers"| Workflow

    Note1[Workflow LLM calls and<br/>Agent LLM can use different models]

    style Workflow fill:#e8f5e9
    style LLMCalls fill:#fff3e0
    style AIAgent fill:#f3e5f5
#+END_SRC

** LLM Client Proxy Benefits

#+BEGIN_SRC mermaid
flowchart TB
    subgraph Clients["Workflow/Agent Clients"]
        C1[Workflow Step]
        C2[AI Agent]
        C3[Another Service]
    end

    subgraph Proxy["LLM Client Proxy"]
        P1[Request Router]
        P2[Cache Layer]
        P3[Tracing/Logging]
        P4[Cost Tracking]
        P5[Rate Limiting]
    end

    subgraph LLMs["LLM Providers"]
        L1[OpenAI]
        L2[Anthropic]
        L3[Local Models]
    end

    C1 --> P1
    C2 --> P1
    C3 --> P1

    P1 --> P2
    P2 --> P3
    P3 --> P4
    P4 --> P5

    P5 --> L1
    P5 --> L2
    P5 --> L3

    P2 -.->|"Cache Hit"| C1
    P3 -.->|"Observability"| Logs[(Logs/Traces)]
    P4 -.->|"Pricing Data"| Metrics[(Cost Metrics)]

    style Proxy fill:#e1f5fe
#+END_SRC

* Synthesis: The Complete Architecture

#+BEGIN_SRC mermaid
flowchart TB
    subgraph UserLayer["User/Client Layer"]
        U1[User Request]
        U2[Scheduled Trigger]
        U3[Event Trigger]
    end

    subgraph AgentLayer["Durable AI Agent Layer"]
        A1[Long-Lived Agent Process]
        A2[Work Queue Monitor]
        A3[Agent State Manager]
    end

    subgraph OrchestrationLayer["Workflow Orchestration Layer"]
        W1[Workflow Engine]
        W2[Step Executor]
        W3[Checkpoint Manager]
        W4[Approval Gate Handler]
    end

    subgraph ActivityLayer["Activity Layer"]
        ACT1[LLM Activities]
        ACT2[Tool Activities]
        ACT3[External Service Activities]
    end

    subgraph PersistenceLayer["Durable Persistence Layer"]
        DB1[(Workflow State)]
        DB2[(Checkpoints)]
        DB3[(Event History)]
        DB4[(Approval Requests)]
    end

    subgraph InfraLayer["Infrastructure Layer"]
        I1[LLM Proxy]
        I2[Message Queue]
        I3[Monitoring/Tracing]
    end

    U1 --> A2
    U2 --> A2
    U3 --> A2

    A2 --> A1
    A1 --> A3
    A1 --> W1

    W1 --> W2
    W2 --> W3
    W2 --> W4

    W2 --> ACT1
    W2 --> ACT2
    W2 --> ACT3

    ACT1 --> I1
    ACT2 --> I2

    W3 --> DB2
    W1 --> DB1
    ACT1 --> DB3
    ACT2 --> DB3
    ACT3 --> DB3
    W4 --> DB4

    A3 --> DB1

    I1 --> I3
    I2 --> I3

    DB2 -.->|"Recovery"| W1
    DB3 -.->|"Replay"| W2

    style AgentLayer fill:#f3e5f5
    style OrchestrationLayer fill:#e8f5e9
    style ActivityLayer fill:#fff8e1
    style PersistenceLayer fill:#e3f2fd
    style InfraLayer fill:#fce4ec
#+END_SRC

* Key Takeaways

1. *Separate deterministic from non-deterministic*: Wrap unpredictable AI decisions in predictable workflow boundaries

2. *Persist everything*: Every LLM response, tool result, and decision must be saved for replay

3. *Checkpoint comprehensively*: Capture full execution context, not just completion status

4. *Design for failure*: Assume crashes will happen; make recovery the default path

5. *Long-lived agents*: Transform ephemeral LLM calls into stateful, resilient processes

* Demo: Camel Visual Tracking Implementation

This section demonstrates how the theoretical concepts are implemented in a real Quarkus + Apache Camel application with SQLite persistence.

** Entity Relationship Model

#+BEGIN_SRC mermaid
erDiagram
    ExchangeState ||--o{ ExchangeCheckpoint : "has many"
    ExchangeState ||--o| ApprovalRequest : "may have"
    ExchangeState }o--|| RouteMetric : "aggregates to"
    ExchangeState ||--o{ RouteLog : "generates"

    ExchangeState {
        string exchangeId PK
        string routeId
        enum status
        int currentStep
        string currentStepName
        text payload
        text context
        datetime createdAt
        datetime startedAt
        datetime completedAt
        datetime lastCheckpoint
    }

    ExchangeCheckpoint {
        long id PK
        string exchangeId FK
        int stepIndex
        string stepName
        text stepData
        datetime timestamp
    }

    ApprovalRequest {
        string id PK
        string exchangeId FK
        string routeId
        text payload
        string status
        datetime createdAt
        datetime completedAt
    }

    RouteMetric {
        string routeId PK
        string status
        long totalCount
        long successCount
        long failureCount
        datetime lastUpdated
    }

    RouteLog {
        long id PK
        string routeId
        string exchangeId
        string eventType
        text message
        datetime timestamp
    }
#+END_SRC

** Core Entities Explained

*** ExchangeState - The Durable Execution Heart

This entity embodies the "persisted checkpoint" concept. It tracks:

#+BEGIN_SRC kotlin
@Entity
@Table(name = "exchange_state")
class ExchangeState(
    @Id
    var exchangeId: String,           // Unique workflow instance ID
    var routeId: String,              // Which workflow type
    var status: ExchangeStatus,       // Current lifecycle state
    var currentStep: Int,             // Position in ordered flow
    var currentStepName: String?,     // Human-readable step identifier
    var payload: String,              // Serialized input/output data
    var context: String?,             // Headers, properties (JSON)
    var lastCheckpoint: LocalDateTime // Recovery timestamp
)

enum class ExchangeStatus {
    PENDING,          // Created, waiting to start
    RUNNING,          // Currently processing
    PAUSED,           // User paused execution
    WAITING_APPROVAL, // Blocked at human approval gate
    CANCELLED,        // User cancelled
    COMPLETED,        // Successfully finished
    FAILED            // Error occurred
}
#+END_SRC

*Key Features:*
- *Payload persistence*: Full execution context survives crashes
- *Position tracking*: =currentStep= and =currentStepName= enable exact recovery point
- *Status machine*: Maps directly to the durable agent lifecycle diagram
- *Recovery queries*: =findRunning()= supports crash recovery scenarios

*** ExchangeCheckpoint - Step-by-Step Audit Trail

Implements fine-grained checkpointing with idempotency:

#+BEGIN_SRC kotlin
@Entity
@Table(name = "exchange_checkpoints")
class ExchangeCheckpoint(
    @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
    var id: Long?,
    var exchangeId: String,    // Links to parent exchange
    var stepIndex: Int,        // Ordered step number
    var stepName: String,      // Step identifier
    var stepData: String?,     // Step-specific context (JSON)
    var timestamp: LocalDateTime
) {
    companion object {
        // Idempotency check prevents duplicate checkpoints
        fun logCheckpoint(exchangeId: String, stepIndex: Int,
                          stepName: String, stepData: String?): Boolean {
            val exists = count("exchangeId = ?1 AND stepName = ?2",
                               exchangeId, stepName) > 0
            if (exists) return false  // Idempotent skip
            ExchangeCheckpoint(...).persist()
            return true
        }
    }
}
#+END_SRC

*Key Features:*
- *Idempotent operations*: Safe to replay without duplicates
- *Granular history*: Every step recorded with timestamp
- *Recovery support*: =getLatestCheckpoint()= finds exact resume point
- *Audit trail*: Complete execution history for debugging

*** ApprovalRequest - Human-in-the-Loop Gate

Implements workflow pausing for human decisions:

#+BEGIN_SRC kotlin
@Entity
@Table(name = "approval_requests")
class ApprovalRequest(
    @Id
    var id: String = UUID.randomUUID().toString(),
    var exchangeId: String,    // Blocked workflow instance
    var routeId: String,       // Workflow type
    var payload: String,       // Data requiring approval
    var status: String,        // PENDING, APPROVED, REJECTED
    var createdAt: LocalDateTime,
    var completedAt: LocalDateTime?
)
#+END_SRC

*Key Features:*
- *Non-blocking persistence*: Workflow waits indefinitely without resource consumption
- *Decision audit*: Approval/rejection timestamped and tracked
- *Resume capability*: Approved requests trigger workflow continuation

*** RouteMetric - Aggregate Observability

Tracks workflow-level statistics:

#+BEGIN_SRC kotlin
@Entity
@Table(name = "route_metrics")
class RouteMetric(
    @Id
    var routeId: String,
    var status: String,
    var totalCount: Long,
    var successCount: Long,
    var failureCount: Long,
    var lastUpdated: LocalDateTime
)
#+END_SRC

*Key Features:*
- *Health monitoring*: Success/failure ratios per workflow type
- *Dashboard support*: Aggregate statistics for UI visualization
- *Trend analysis*: Track workflow performance over time

*** RouteLog - Event Audit Trail

Provides detailed event logging:

#+BEGIN_SRC kotlin
@Entity
@Table(name = "route_logs")
class RouteLog(
    @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
    var id: Long?,
    var routeId: String,
    var exchangeId: String,
    var eventType: String,     // STARTED, COMPLETED, FAILED, etc.
    var message: String?,      // Human-readable details
    var timestamp: LocalDateTime
)
#+END_SRC

*Key Features:*
- *Debugging support*: Detailed event history for troubleshooting
- *Observability*: Complements the "Agent History" concept
- *Filtering*: Query by route, exchange, or event type

** How Entities Map to Concepts

#+BEGIN_SRC mermaid
flowchart TB
    subgraph Concepts["Theoretical Concepts"]
        C1[Durable Execution]
        C2[Checkpointing]
        C3[Human-in-the-Loop]
        C4[Observability]
        C5[Recovery]
    end

    subgraph Entities["Hibernate Entities"]
        E1[ExchangeState]
        E2[ExchangeCheckpoint]
        E3[ApprovalRequest]
        E4[RouteMetric]
        E5[RouteLog]
    end

    C1 --> E1
    C2 --> E2
    C3 --> E3
    C4 --> E4
    C4 --> E5
    C5 --> E1
    C5 --> E2

    style Concepts fill:#e8f5e9
    style Entities fill:#e3f2fd
#+END_SRC

** Workflow Lifecycle with Entities

#+BEGIN_SRC mermaid
sequenceDiagram
    participant User
    participant API
    participant Camel as Camel Route
    participant ES as ExchangeState
    participant EC as ExchangeCheckpoint
    participant AR as ApprovalRequest
    participant RL as RouteLog

    User->>API: Submit workflow
    API->>ES: Create (PENDING)
    API->>RL: Log "CREATED"

    Camel->>ES: Update (RUNNING)
    Camel->>EC: Checkpoint Step 1
    Camel->>RL: Log "STEP_COMPLETED"

    Camel->>EC: Checkpoint Step 2
    Camel->>RL: Log "STEP_COMPLETED"

    Note over Camel: Reaches approval gate
    Camel->>ES: Update (WAITING_APPROVAL)
    Camel->>AR: Create (PENDING)
    Camel->>RL: Log "WAITING_APPROVAL"

    User->>API: Approve request
    API->>AR: Update (APPROVED)
    API->>ES: Update (RUNNING)
    API->>RL: Log "RESUMED"

    Camel->>EC: Checkpoint Step 3
    Camel->>ES: Update (COMPLETED)
    Camel->>RL: Log "COMPLETED"
#+END_SRC

** Crash Recovery Flow

#+BEGIN_SRC mermaid
flowchart TB
    subgraph BeforeCrash["Before Crash"]
        B1[Exchange RUNNING]
        B2[Checkpoint at Step 2]
        B3[Processing Step 3]
    end

    subgraph Crash["System Crash"]
        C1[Process Terminates]
    end

    subgraph Recovery["After Restart"]
        R1[Query: findRunning]
        R2[Load ExchangeState]
        R3[Load Latest Checkpoint]
        R4[Resume from Step 3]
    end

    subgraph Database["SQLite Database"]
        DB1[(ExchangeState<br/>status: RUNNING<br/>currentStep: 2)]
        DB2[(Checkpoints<br/>Step 1 ✓<br/>Step 2 ✓)]
    end

    B1 --> B2 --> B3
    B3 --> C1
    C1 --> R1

    R1 --> DB1
    DB1 --> R2
    R2 --> R3
    R3 --> DB2
    DB2 --> R4

    style Crash fill:#ffcdd2
    style Recovery fill:#c8e6c9
    style Database fill:#e3f2fd
#+END_SRC

** Technology Stack

| Layer           | Technology              | Purpose                                    |
|-----------------+-------------------------+--------------------------------------------|
| Framework       | Quarkus 3.x             | Kubernetes-native, fast startup            |
| ORM             | Hibernate Panache       | Active Record pattern for Kotlin           |
| Database        | SQLite with WAL mode    | Lightweight, ACID-compliant persistence    |
| Integration     | Apache Camel 4.x        | Workflow orchestration and routing         |
| Language        | Kotlin                  | Concise, null-safe JVM language            |
| Serialization   | Kotlinx Serialization   | JSON for payload and context fields        |

** Code Location

#+BEGIN_SRC text
src/main/kotlin/com/outcastgeek/ubntth/entities/
├── ExchangeState.kt       # Core durable execution state
├── ExchangeCheckpoint.kt  # Step-by-step checkpoints
├── ApprovalRequest.kt     # Human-in-the-loop gates
├── RouteMetric.kt         # Aggregate metrics
└── RouteLog.kt            # Event audit trail
#+END_SRC

* References

** Durable Execution Frameworks
- Temporal Durable Execution: https://docs.temporal.io/workflows
- Temporal + AI Agents: https://temporal.io/blog/of-course-you-can-build-dynamic-ai-agents-with-temporal
- Common Pitfalls with Durable Execution: https://medium.com/@cgillum/common-pitfalls-with-durable-execution-frameworks-like-durable-functions-or-temporal-eaf635d4a8bb

** AI Agent Persistence
- LangGraph Persistence System: https://deepwiki.com/langchain-ai/langgraph/4-persistence-system
- Pydantic AI + Temporal: https://temporal.io/blog/build-durable-ai-agents-pydantic-ai-and-temporal
- Microsoft Durable Multi-Agent Orchestration: https://techcommunity.microsoft.com/blog/appsonazureblog/building-durable-and-deterministic-multi-agent-orchestrations-with-durable-execu/4408842

** Additional Resources
- Temporal Learn Tutorials: https://learn.temporal.io/tutorials/
- Databricks Stateful Agents: https://docs.databricks.com/aws/en/generative-ai/agent-framework/stateful-agents
- Building LangGraph (Design Principles): https://blog.langchain.com/building-langgraph/
